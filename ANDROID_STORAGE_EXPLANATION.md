# Android Image Storage & Inspection Management

## How Images Are Stored in Android

### 1. Image Storage Structure

When a photo is captured in the WebView, it goes through this flow:

```
WebView (React) 
  → Captures image as data URL
  → Converts to base64
  → Calls AndroidImageStore.saveImage(fileName, base64Data, contentType)
  → Android app saves to local storage
  → Returns local file path/URI
```

### 2. Android Storage Paths

The Android app should store images in a structured way:

```
/storage/emulated/0/Android/data/com.yourapp.package/files/
  └── inspections/
      └── images/
          ├── 2024-01-15_ABC123_MORNING/
          │   ├── front_1705312800000.jpg
          │   ├── right_front_fender_1705312801000.jpg
          │   ├── right_front_door_1705312802000.jpg
          │   ├── right_rear_door_1705312803000.jpg
          │   ├── right_rear_fender_1705312804000.jpg
          │   ├── rear_1705312805000.jpg
          │   ├── left_rear_fender_1705312806000.jpg
          │   ├── left_rear_door_1705312807000.jpg
          │   └── left_front_door_1705312808000.jpg
          │
          └── 2024-01-15_ABC123_EVENING/
              ├── front_1705356000000.jpg
              └── ... (10 images)
```

**OR using Android's internal storage:**

```
/data/data/com.yourapp.package/files/inspections/
  └── images/
      └── [same structure as above]
```

### 3. File Naming Convention

Each image file is named:
```
car_{segmentId}-{timestamp}.jpg
```

Example:
- `car_front-1705312800000.jpg`
- `car_right_front_fender-1705312801000.jpg`

The Android app receives:
- `fileName`: `car_front-1705312800000.jpg`
- `base64Payload`: Base64 encoded image data
- `contentType`: `image/jpeg`

The Android app should:
1. Decode base64 to byte array
2. Save to file system
3. Return the full file path/URI (e.g., `/storage/.../car_front-1705312800000.jpg`)

### 4. Inspection Data Storage

When `savePendingInspection()` is called, the Android app should store:

**Database Table: `pending_inspections`**
```sql
CREATE TABLE pending_inspections (
    local_inspection_id TEXT PRIMARY KEY,  -- UUID generated by Android
    registration_number TEXT NOT NULL,
    session_type TEXT NOT NULL,            -- 'MORNING' or 'EVENING'
    client_name TEXT NOT NULL,
    vehicle_make TEXT,
    vehicle_model TEXT,
    created_at INTEGER NOT NULL,            -- Unix timestamp
    synced INTEGER DEFAULT 0,              -- 0 = false, 1 = true
    synced_at INTEGER,                     -- Unix timestamp when synced
    inspection_id INTEGER,                  -- From API after sync
    retry_count INTEGER DEFAULT 0,
    last_error TEXT,
    date TEXT NOT NULL                      -- YYYY-MM-DD format
);
```

**Database Table: `pending_inspection_images`**
```sql
CREATE TABLE pending_inspection_images (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    local_inspection_id TEXT NOT NULL,     -- Foreign key
    segment_id TEXT NOT NULL,              -- 'front', 'rear', etc.
    local_path TEXT NOT NULL,              -- Full file path
    upload_status TEXT DEFAULT 'PENDING',   -- 'PENDING', 'UPLOADING', 'UPLOADED', 'FAILED'
    s3_url TEXT,                           -- After upload
    upload_error TEXT,
    FOREIGN KEY (local_inspection_id) REFERENCES pending_inspections(local_inspection_id)
);
```

## Handling Same Car Number Next Day

### Scenario: Morning Inspection Today, Evening Inspection Tomorrow

**Day 1 (2024-01-15) - Morning:**
```
Registration: ABC123
Session: MORNING
Date: 2024-01-15
Local ID: uuid-12345
Status: PENDING
```

**Day 2 (2024-01-16) - Evening:**
```
Registration: ABC123
Session: EVENING
Date: 2024-01-16
Local ID: uuid-67890
Status: PENDING
```

### How to Handle:

1. **When saving evening inspection:**
   - Check if morning inspection exists for same `registration_number` and `date`
   - If found: Link evening to morning's `local_inspection_id` (or create a parent record)
   - If not found: Create new inspection (morning might be on different day or not done)

2. **When syncing to server:**
   - Upload morning inspection first (if exists for same date)
   - Get `inspectionId` from API
   - When evening is ready to sync:
     - Check if morning exists and is synced
     - If yes: Submit evening with reference to morning's `inspectionId`
     - If no: Submit evening as new inspection

3. **Database Structure for Linking:**
   ```sql
   -- Add to pending_inspections table:
   linked_morning_id TEXT,  -- Reference to morning inspection's local_inspection_id
   linked_inspection_id INTEGER  -- Server inspectionId after sync
   ```

### Example Flow:

**Day 1 - Morning (8:00 AM, offline):**
```
1. Capture 10 images → Save to: /inspections/images/2024-01-15_ABC123_MORNING/
2. Create pending_inspection record:
   - local_inspection_id: "uuid-12345"
   - registration_number: "ABC123"
   - session_type: "MORNING"
   - date: "2024-01-15"
   - synced: 0
3. Create 9 pending_inspection_images records linking to uuid-12345
```

**Day 1 - Network Available (10:00 AM):**
```
1. Android background service detects network
2. Process pending inspection uuid-12345:
   - Upload 10 images to S3 → Get S3 URLs
   - Call API: submitCarInspection() with S3 URLs
   - API returns: inspectionId = 789
3. Update database:
   - Set synced = 1
   - Set inspection_id = 789
   - Set synced_at = current_timestamp
```

**Day 2 - Evening (6:00 PM, offline):**
```
1. Capture 10 images → Save to: /inspections/images/2024-01-16_ABC123_EVENING/
2. Check database: Does morning exist for ABC123 on 2024-01-16?
   - No (morning was on 2024-01-15, different day)
   - Create new pending_inspection:
     - local_inspection_id: "uuid-67890"
     - registration_number: "ABC123"
     - session_type: "EVENING"
     - date: "2024-01-16"
     - synced: 0
3. Create 9 pending_inspection_images records
```

**Day 2 - Network Available (7:00 PM):**
```
1. Process pending inspection uuid-67890:
   - Upload 10 images to S3
   - Call API: submitCarInspection() 
   - API returns: inspectionId = 790 (new inspection, different day)
```

### Same Day - Morning + Evening:

**Morning (8:00 AM, offline):**
```
- local_inspection_id: "uuid-morning"
- date: "2024-01-15"
- session_type: "MORNING"
```

**Evening (6:00 PM, offline):**
```
1. Check: Does morning exist for ABC123 on 2024-01-15?
   - Yes! Found uuid-morning
   - Create evening inspection:
     - local_inspection_id: "uuid-evening"
     - linked_morning_id: "uuid-morning"  ← Link to morning
     - date: "2024-01-15"
     - session_type: "EVENING"
```

**When syncing:**
```
1. Sync morning first (uuid-morning):
   - Upload images → Get inspectionId = 789
   - Update uuid-morning: inspection_id = 789, synced = 1

2. Sync evening (uuid-evening):
   - Check linked_morning_id → Found uuid-morning
   - Check uuid-morning.synced → Yes, inspection_id = 789
   - Upload evening images → Get S3 URLs
   - Call API: submitCarInspection() with reference to inspectionId 789
   - API links evening to morning inspection
```

## Android Implementation Checklist

### 1. Image Storage (`AndroidImageStore.saveImage`)
- [ ] Create directory structure: `/inspections/images/{date}_{regNumber}_{sessionType}/`
- [ ] Decode base64 to byte array
- [ ] Save image file
- [ ] Return full file path/URI

### 2. Inspection Storage (`AndroidBridge.savePendingInspection`)
- [ ] Generate UUID for `local_inspection_id`
- [ ] Extract date from current timestamp (YYYY-MM-DD)
- [ ] Check if morning inspection exists (for evening sessions)
- [ ] Save to `pending_inspections` table
- [ ] Save all images to `pending_inspection_images` table
- [ ] Return `local_inspection_id`

### 3. Sync Service
- [ ] Monitor network connectivity
- [ ] Process pending inspections in priority order (MORNING before EVENING)
- [ ] Upload images to S3 (get presigned URLs, upload files)
- [ ] Call API with S3 URLs
- [ ] Update database with `inspection_id` and `synced = 1`
- [ ] Handle retries for failed uploads

### 4. Query Functions
- [ ] `getInspectionStatus(localId)` - Check if synced, get inspectionId
- [ ] `getPendingInspections()` - List all pending
- [ ] `getInspectionsByRegistration(regNumber, date)` - Find morning/evening pairs

